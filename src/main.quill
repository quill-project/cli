
mod quill::cli

use files::catch_os_while
use terminal::style::*
use os::fs

fun generate_usage_info() -> String {
    val self_exec: String = os::env::args() |> at(0)
    val header: Fun(String) -> String = |t| "\n"
        |> concat(t |> style(BOLD, BRIGHT_WHITE) )
        |> concat("\n")
    val item: Fun(String) -> String = |t| "\n"
        |> concat(t |> style(WHITE, ON_BRIGHT_BLACK))
        |> concat("\n")
    val descr: Fun(String) -> String 
        = |t| t |> style(WHITE)
        |> concat("\n")
    val o = StringBuilder::empty()
    o |> push(header("USAGE"))
    o |> push(item(" _ new ('application'/'library'/'dyn_library'/'plugin') (NAME) " |> fmt(self_exec)))
    o |> push(descr("\tCreates a new package with the given type and name in a new directory of the same name."))
    o |> push(item(" _ init ('application'/'library'/'dyn_library'/'plugin') " |> fmt(self_exec)))
    o |> push(descr("\tInitializes the current working directory as a new package with the given type."))
    o |> push(descr("\tThe name of the current working directory is used as the package name."))
    o |> push(item(" _ build ('debug'/'release') " |> fmt(self_exec)))
    o |> push(descr("\tBuilds the application package in the current working directory."))
    o |> push(item(" _ clean " |> fmt(self_exec)))
    o |> push(descr("\tRemoves any files generated by Quill from the package directory."))
    o |> push(header("ENVIRONMENT VARIABLES"))
    o |> push(item(" QUILL_GIT "))
    o |> push(descr("\tThe Git implementation to use for downloading dependencies."))
    o |> push(descr("\tDefault: 'git'"))
    o |> push(item(" QUILL_CC "))
    o |> push(descr("\tThe C compiler to use for compilation when using the C backend."))
    o |> push(descr("\tDefault: 'cc'"))
    o |> push(item(" QUILL_CC_FLAGS "))
    o |> push(descr("\tAdditional flags that should be passed to the C compiler when using the C backend."))
    o |> push(item(" QUILL_NPROC "))
    o |> push(descr("\tAn integer specfifying the number of cores the Quill compiler should use for compilation."))
    o |> push(descr("\tDefault: [N - 2] (where 'N' is the number of cores available)"))
    return o |> as_string()
}

fun main() {
    val args: List[String] = os::env::args()
    val arg_c: Int = args |> length()
    if arg_c <= 1 {
        println(generate_usage_info())
        os::exit(2)
    }
    val req_arg_c: Fun(Int) = |r_arg_c| {
        if arg_c == r_arg_c { return unit }
        println(generate_usage_info())
        os::exit(2)
    }
    match args |> at(1) {
        "new" {
            req_arg_c(4)
            val type: String = args |> at(2)
            val name: String = args |> at(3)
            log::creating(name, || {
                fs::create_dir(name)
                    |> catch_os_while[Unit]("creating package directory")
                files::create_package(name, name, type)
            })
        }
        "init" {
            req_arg_c(3)
            val type: String = args |> at(2)
            val cwd: String = os::fs::path::get_cwd()
            val name: String = cwd 
                |> split(os::fs::path::FILE_SEP)
                |> last() 
                |> expect("'split' returns at least 1 element")
            log::creating(name, || {
                files::create_package(".", name, type)
            })
        }
        "build" {
            req_arg_c(3)
            val mode: build::Mode = args |> at(2) |> build::Mode::parse()
            val config_text = fs::read_file(build::CONFIG_FILE_LOC)
                |> catch_os_while[String](
                    "reading '_'" |> fmt(build::CONFIG_FILE_LOC)
                )
            val config = pkg::Config::parse(config_text, build::CONFIG_FILE_LOC)
            match config.type {
                Application(main) { 
                    build::build(config, mode, main)
                }
                DynLibrary {
                    build::build_dyn(
                        config, mode, build::OUT_DIR, build::FORCE_RECOMP
                    )
                }
                _ {
                    "'_' is not an application or dynamic library!" 
                        |> fmt(config.name) 
                        |> log::error()
                }
            }
        }
        "bundle" {
            req_arg_c(2)
            val config_text = fs::read_file(build::CONFIG_FILE_LOC)
                |> catch_os_while[String](
                    "reading '_'" |> fmt(build::CONFIG_FILE_LOC)
                )
            val config = pkg::Config::parse(config_text, build::CONFIG_FILE_LOC)
            match config.type {
                Application(main) {
                    build::bundle(config, main)
                }
                _ {
                    log::error("'_' is not an application!" |> fmt(config.name))
                }
            }
        }
        "clean" {
            if fs::is_dir(build::OUT_DIR) {
                log::cleaning(|| {
                    files::nuke_dir(build::OUT_DIR)
                })
            }
        }
        other {
            log::error("'_' is not a known subcommand!" |> fmt(other))
        }
    }
}

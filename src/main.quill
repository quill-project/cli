
mod quill::cli

use files::catch_os_while
use terminal::style::*
use os::fs

fun generate_usage_info() -> String {
    val self_exec: String = os::env::args() |> at(0)
    val header: Fun(String) -> String = |t| "\n"
        |> concat(t |> style(BOLD, BRIGHT_WHITE) )
        |> concat("\n")
    val item: Fun(String) -> String = |t| "\n"
        |> concat(t |> style(WHITE, ON_BRIGHT_BLACK))
        |> concat("\n")
    val descr: Fun(String) -> String 
        = |t| t |> style(WHITE)
        |> concat("\n")
    val o = StringBuilder::empty()
    o |> push(header("USAGE"))
    o |> push(item(" _ new ('application'/'library'/'plugin') (NAME) " |> fmt(self_exec)))
    o |> push(descr("\tCreates a new package with the given type and name in a new directory of the same name."))
    o |> push(item(" _ init ('application'/'library'/'plugin') " |> fmt(self_exec)))
    o |> push(descr("\tInitializes the current working directory as a new package with the given type."))
    o |> push(descr("\tThe name of the current working directory is used as the package name."))
    o |> push(item(" _ build ('debug'/'release') " |> fmt(self_exec)))
    o |> push(descr("\tBuilds the application package in the current working directory."))
    o |> push(item(" _ clean " |> fmt(self_exec)))
    o |> push(descr("\tRemoves any files generated by Quill from the package directory."))
    o |> push(header("ENVIRONMENT VARIABLES"))
    o |> push(item(" QUILL_GIT "))
    o |> push(descr("\tThe Git implementation to use for downloading dependencies."))
    o |> push(descr("\tDefault: 'git'"))
    o |> push(item(" QUILL_CC "))
    o |> push(descr("\tThe C compiler to use for compilation when using the C backend."))
    o |> push(descr("\tDefault: 'cc'"))
    o |> push(item(" QUILL_CC_FLAGS "))
    o |> push(descr("\tAdditional flags that should be passed to the C compiler when using the C backend."))
    o |> push(item(" QUILL_C_NO_LTO "))
    o |> push(descr("\tDisables usage of link time optimization when compiling in release mode using the C backend."))
    o |> push(descr("\tAny non-empty value disables usage of LTO."))
    o |> push(descr("\tDefault: LTO enabled"))
    return o |> as_string()
}

fun main() {
    val args: List[String] = os::env::args()
    val arg_c: Int = args |> length()
    if arg_c <= 1 {
        println(generate_usage_info())
        os::exit(2)
    }
    val req_arg_c: Fun(Int) = |r_arg_c| {
        if arg_c == r_arg_c { return unit }
        println(generate_usage_info())
        os::exit(2)
    }
    match args |> at(1) {
        "new" {
            req_arg_c(4)
            val type: String = args |> at(2)
            val name: String = args |> at(3)
            fs::create_dir(name)
                |> catch_os_while[Unit]("creating package directory")
            files::create_package(name, name, type)
            log::created(name)
        }
        "init" {
            req_arg_c(3)
            val type: String = args |> at(2)
            val cwd: String = os::fs::path::get_cwd()
            val name: String = cwd 
                |> split(os::fs::path::FILE_SEP)
                |> last() 
                |> expect("'split' returns at least 1 element")
            files::create_package(".", name, type)
            log::created(name)
        }
        "build" {
            req_arg_c(3)
            // TODO!
            return panic("not yet implemented")
        }
        "clean" {
            if fs::is_dir(".quill") {
                files::nuke_dir(".quill")
            }
            log::cleaned()
        }
        other {
            log::error("'_' is not a known subcommand!" |> fmt(other))
        }
    }
}

// use os::fs

// pub fun read_dir_rec(path: String) -> List[String]
//     = fs::read_dir(path) 
//     |> unwrap_or(List::empty())
//     |> values()
//     |> map[String, List[String]](|name| {
//         val full: String = fs::path::join(path, name)
//         return if fs::is_dir(full) { read_dir_rec(full) }
//             else { List::of(full) }
//     })
//     |> reduce(List::concat)
//     |> unwrap_or(List::empty())

// val PACKAGE_DIRS: List[String] = List::of(
//     "runtime-c",
//     "std-c",
//     "std",
//     "compiler",
//     "os",
//     "conc",
//     "cli"
// )
// val PKG_SRC_DIR: String = "src"
// val PKG_EXT_DIR: String = "src-c"
// val PKG_INC_DIR: String = "src-c/include"
// val ENTRY_POINT: String = "quill::cli::main"
// val C_OUTPUT_PATH: String = "bootstrap/build.c"
// val BIN_OUTPUT_PATH: String = "bootstrap/build"

// use quill::(
//     Message,
//     lexer, token::Token,
//     parser::(Parser, parse_file), ast::UntypedNode,
//     types::(SymbolTable, SymbolInstance, PreparedInstance, CheckedInstance),
//     codegen
// )
// use conc::(Mutex, Thread)

// val CHECKER_THREAD_COUNT: Int = 10

// fun main() {
//     val source_paths: List[String] = PACKAGE_DIRS
//         |> values()
//         |> map[String, String](|d| fs::path::join(d, PKG_SRC_DIR))
//         |> map(read_dir_rec)
//         |> reduce(List::concat)
//         |> unwrap_or_else(List::empty)
//     val sources: Map[String, String] = source_paths
//         |> values()
//         |> map(|path| Pair(path, fs::read_file(path) |> unwrap()))
//         |> Map::collect()
//     val unl_messages: mut List[Message] = List::empty()
//     // parse all source files
//     val nodes: List[UntypedNode] = sources
//         |> entries()
//         |> map[Pair[String, String], List[UntypedNode]](|s| {
//             val tokens: mut Stream[Token]
//                 = lexer::tokenize(s.first, s.second, unl_messages)
//             return Parser::from(tokens, unl_messages) |> parse_file()
//         })
//         |> reduce(List::concat)
//         |> unwrap_or_else(List::empty)
//     // build a symbol table and check all symbols
//     val unl_table = SymbolTable::from(nodes, unl_messages)
//     val worker_table: mut Mutex[mut SymbolTable] 
//         = Mutex::new(unl_table)
//     val worker_queue: mut Mutex[mut List[SymbolInstance]]
//         = Mutex::new(unl_table |> base_instances())
//     val worker_msgs: mut Mutex[mut List[Message]]
//         = Mutex::new(unl_messages)
//     val worker: Fun() = || {
//         val check_symbol: Fun(PreparedInstance) = |p_i| {
//             val deps: mut List[SymbolInstance] = List::empty()
//             val msgs: mut List[Message] = List::empty()
//             val ch_i: CheckedInstance = unl_table 
//                 |> check_prepared_symbol(p_i, deps, msgs)
//             worker_table |> take(|t| {
//                 t.value |> register_checked_symbol(ch_i)
//                 worker_queue |> take(|q| {
//                     deps |> values()
//                         |> filter(|d| !(t.value |> has_instance(d)))
//                         |> for_each(|d| { q.value |> push(d) })
//                 })
//             })
//             worker_msgs |> take(|m| {
//                 msgs |> values() |> for_each(|msg| { m.value |> push(msg) })
//             })
//         }
//         val prepare_symbol: Fun(SymbolInstance) = |i| {
//             val prep_i: Option[PreparedInstance]
//                 = worker_table |> compute(|t| t |> prepare_check_symbol(i))
//             match prep_i {
//                 Some(p_i) { check_symbol(p_i) }
//                 None {}
//             }
//         }
//         while true {
//             val next: Option[SymbolInstance] 
//                 = worker_queue |> compute(|q| q |> pop())
//             match next {
//                 None { break }
//                 Some(i) { prepare_symbol(i) } 
//             }
//         }
//     }
//     val workers: List[Thread] = range(0, CHECKER_THREAD_COUNT)
//         |> map(|_| Thread::spawn(worker))
//         |> List::collect()
//     workers |> values() |> for_each(Thread::join)
//     // report messages and exit if has any
//     if unl_messages |> values() |> any(Message::is_error) {
//         unl_messages |> values() 
//             |> map[Message, String](
//                 |m| m |> display(sources, true) |> concat("\n")
//             ) 
//             |> for_each(println)
//         return unit
//     }
//     // emit code
//     val output: String = codegen::c::emit(
//         unl_table, 
//         ENTRY_POINT |> split("::") |> List::collect(), 
//         unl_messages
//     )
//     // report messages and exit if has any
//     unl_messages |> values() 
//         |> map[Message, String](
//             |m| m |> display(sources, true) |> concat("\n")
//         ) 
//         |> for_each(println)
//     if unl_messages |> values() |> any(Message::is_error) {
//         return unit
//     }
//     // write output
//     output |> fs::write_file(C_OUTPUT_PATH) |> unwrap()
//     // generate C build command
//     val ext_c_files: String = PACKAGE_DIRS
//         |> values()
//         |> map[String, String](|d| fs::path::join(d, PKG_EXT_DIR))
//         |> map(read_dir_rec)
//         |> reduce(List::concat)
//         |> unwrap_or_else(List::empty)
//         |> values()
//         |> filter(|p| p |> ends_with(".c"))
//         |> join(" ")
//     val ext_inc_dirs: String = PACKAGE_DIRS
//         |> values()
//         |> map[String, String](|d| fs::path::join(d, PKG_INC_DIR))
//         |> filter(fs::is_dir)
//         |> map[String, String](|d| "-I " |> concat(d))
//         |> join(" ")
//     val cc_cmd: String = "cc _ _ _ -lm -O3 -flto -o _"
//         |> fmt(C_OUTPUT_PATH, ext_c_files, ext_inc_dirs, BIN_OUTPUT_PATH)
//     println(cc_cmd)
// }


mod quill::cli::files

use quill::cli::(pkg, log, build)
use os::(fs, fs::path)

pub fun catch_os_while[T](r: Result[T, os::Error], doing: String) -> T {
    match r {
        Ok(v) { return v }
        Err(e) {
            log::error_while(doing, os::Error::as_string(e))
            return panic("unreachable")
        }
    }
}

pub fun create_package(path: String, name: String, type: String) {
    val config_path: String = path::join(path, build::CONFIG_FILE_LOC)
    create_config(config_path, name, type)
    val gitignore_path: String = path::join(path, ".gitignore")
    create_gitignore(gitignore_path)
    val source_dir: String = path::join(path, build::QUILL_SRC_DIR)
    fs::create_dir(source_dir)
        |> catch_os_while("creating project source directory")
    create_main_file(source_dir, name, type)
}

use json::Json

fun get_username_string() -> String
    = os::env::get_var("USERNAME")
    |> or_else(|| os::env::get_var("USER"))
    |> or_else(|| os::env::get_var("LOGNAME"))
    |> map[String, String](|u| Json::as_string(Json::String(u)))
    |> unwrap_or("")

val APP_CONFIG_TEMPLATE: String = "\
{
    \"name\": \"_\",
    \"authors\": [_],
    \"description\": \"\",
    \"type\": \"application\",
    \"main\": \"_::main\",
    \"backend\": \"c\",
    \"dependencies\": [
        \"https://github.com/quill-project/std-c\"
    ]
}
"

val LIB_CONFIG_TEMPLATE: String = "\
{
    \"name\": \"_\",
    \"authors\": [_],
    \"description\": \"\",
    \"type\": \"_\",
    \"backend\": \"_\",
    \"dependencies\": [
        _
    ]
}
"

val PLUGIN_CONFIG_TEMPLATE: String = "\
{
    \"name\": \"_\",
    \"authors\": [_],
    \"description\": \"\",
    \"type\": \"plugin\",
    \"backend\": \"c\",
    \"dependencies\": [
        \"https://github.com/quill-project/std-c\",
        \"https://github.com/quill-project/macro\"
    ],
    \"macros\": {
        \"debug\": \"_::debug\"
    }
}
"

pub fun create_config(path: String, name: String, type: String) {
    val user: String = get_username_string()
    match type {
        "application" {
            val content: String = APP_CONFIG_TEMPLATE |> fmt(name, user, name)
            fs::write_file(content, path) 
                |> catch_os_while[Unit]("creating package config")
        }
        "library" {
            val content: String = LIB_CONFIG_TEMPLATE |> fmt(
                name, user, type, "any", 
                "\"https://github.com/quill-project/std\""
            )
            fs::write_file(content, path) 
                |> catch_os_while[Unit]("creating package config")
        }
        "dyn_library" {
            val content: String = LIB_CONFIG_TEMPLATE |> fmt(
                name, user, type, "c", 
                "\"https://github.com/quill-project/std-c\""
            )
            fs::write_file(content, path) 
                |> catch_os_while[Unit]("creating package config")
        }
        "plugin" {
            val content: String = PLUGIN_CONFIG_TEMPLATE 
                |> fmt(name, user, name)
            fs::write_file(content, path)
                |> catch_os_while[Unit]("creating package config")
        }
        _ {
            log::error("'_' is not a known package type!" |> fmt(type))
        }
    }
}

val GITIGNORE_TEMPLATE: String = "\
_
"

pub fun create_gitignore(path: String) {
    GITIGNORE_TEMPLATE
        |> fmt(quill::cli::build::OUT_DIR)
        |> fs::write_file(path)
        |> catch_os_while[Unit]("creating .gitignore template")
}

val APP_MAIN_TEMPLATE: String = "\

mod _

fun main() {
    println(\"Hello, world!\")
}
"

val LIB_MAIN_TEMPLATE: String = "\

mod _

fun add(a: Int, b: Int) -> Int {
    return a + b
}
"

val PLUGIN_MAIN_TEMPLATE: String = "\

mod _

use macro::*

pub fun debug(input: List[Token], ctx: Compiler) -> List[Token] {
    ctx // unused
    input |> values() 
        |> map[Token, String](|t| t.content) 
        |> join(\" \") 
        |> println()
    return input
}
"

pub fun create_main_file(source_dir: String, name: String, type: String) {
    mut path: String = ""
    mut content: String = ""
    match type {
        "application" {
            path = path::join(source_dir, "main.quill")
            content = APP_MAIN_TEMPLATE |> fmt(name)
        }
        "plugin" {
            path = path::join(source_dir, name |> concat(".quill"))
            content = PLUGIN_MAIN_TEMPLATE |> fmt(name)
        }
        _ {
            path = path::join(source_dir, name |> concat(".quill"))
            content = LIB_MAIN_TEMPLATE |> fmt(name)
        }
    }
    fs::write_file(content, path)
        |> catch_os_while[Unit]("creating main file")
}

pub fun nuke_dir(dir: String) {
    fs::read_dir(dir)
        |> unwrap_or(List::empty())
        |> values()
        |> for_each(|name| {
            val file: String = path::join(dir, name)
            if fs::is_dir(file) { 
                nuke_dir(file) 
            } else {
                fs::delete_file(file)
                    |> catch_os_while[Unit]("deleting '_'" |> fmt(file))
            }
        })
    fs::delete_dir(dir)
        |> catch_os_while[Unit]("deleting '_'" |> fmt(dir))
}

pub fun read_dir_rec(dir: String, out: mut Set[String]) {
    val names: List[String] = fs::read_dir(dir)
        |> unwrap_or(List::empty())
    for name: names |> values() {
        val file: String = path::join(dir, name)
        if fs::is_dir(file) {
            read_dir_rec(file, out)
        } else {
            out |> add(file)
        }
    }
}

pub fun ensure_dir_exists(dir: String) {
    if fs::file_exists(dir) { return unit }
    fs::create_dir(dir)
        |> catch_os_while[Unit]("creating directory '_'" |> fmt(dir))
}